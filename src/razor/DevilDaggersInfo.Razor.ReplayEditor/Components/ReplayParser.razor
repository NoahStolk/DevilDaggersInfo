@using DevilDaggersInfo.Common
@using DevilDaggersInfo.Common.Extensions
@using DevilDaggersInfo.Core.Replay
@using DevilDaggersInfo.Core.Replay.Events
@using DevilDaggersInfo.Core.Wiki
@using DevilDaggersInfo.Core.Wiki.Enums
@using DevilDaggersInfo.Core.Wiki.Objects
@using DevilDaggersInfo.Razor.ReplayEditor.Enums
@using DevilDaggersInfo.Razor.ReplayEditor.Services
@using DevilDaggersInfo.Razor.ReplayEditor.Store.State
@using Fluxor
@inherits FluxorComponent
@inject IState<ReplayBinaryState> ReplayBinaryState
@inject IState<ReplayEditorState> ReplayEditorState
@inject StateFacade StateFacade

@{
	ReplayBinary replayBinary = ReplayBinaryState.Value.ReplayBinary;
	int startTick = ReplayEditorState.Value.StartTick;
	int endTick = ReplayEditorState.Value.EndTick;

	bool f = startTick <= 0;
	bool l = endTick >= replayBinary.EventsPerTick.Count - 1;
	const string disabledStyle = "disabled:opacity-50 cursor-default btn-disabled";
	const string enabledStyle = "btn-gray";

	Death? death = Deaths.GetDeathByLeaderboardType(GameVersion.V3_2, (byte)replayBinary.Header.DeathType);
}

<h2 class="text-red text-2xl pt-4 pb-2 font-goethe">Header</h2>

<div class="grid grid-cols-2 gap-x-2 max-w-md">
	<div>Version</div>
	<div>@replayBinary.Header.Version</div>
	<div>Timestamp</div>
	<div>@replayBinary.Header.TimestampSinceGameRelease</div>
	<div>Time</div>
	<div>@replayBinary.Header.Time.ToString(StringFormats.TimeFormat)</div>
	<div>Start Time</div>
	<div>@replayBinary.Header.StartTime.ToString(StringFormats.TimeFormat)</div>
	<div>Kills</div>
	<div>@replayBinary.Header.Kills</div>
	<div>Gems</div>
	<div>@replayBinary.Header.Gems</div>
	<div>Daggers Hit</div>
	<div>@replayBinary.Header.DaggersHit</div>
	<div>Daggers Fired</div>
	<div>@replayBinary.Header.DaggersFired</div>
	<div>Death Type</div>
	@if (death.HasValue)
	{
		<div style="color: @death.Value.Color.HexCode">@death.Value.Name</div>
	}
	else
	{
		<div>Invalid death type</div>
	}
	<div>Player ID</div>
	<div>@replayBinary.Header.PlayerId</div>
	<div>Player Name</div>
	<div>@replayBinary.Header.Username</div>
	<div>Spawnset MD5</div>
	<div>@replayBinary.Header.SpawnsetMd5.ByteArrayToHexString()</div>
</div>

<h2 class="text-red text-2xl pt-4 pb-2 font-goethe">Events @startTick - @endTick (@((startTick / 60f).ToString(StringFormats.TimeFormat)) - @((endTick / 60f).ToString(StringFormats.TimeFormat)))</h2>

<div class="flex">
	<div class="w-10 h-10 mx-1">
		<button disabled="@f" class="@(f ? disabledStyle : enabledStyle) btn" @onclick="() => StateFacade.SelectTickRange(0, 60)">@MarkupStrings.NavStart</button>
	</div>
	<div class="w-10 h-10 mx-1">
		<button disabled="@f" class="@(f ? disabledStyle : enabledStyle) btn" @onclick="() => StateFacade.SelectTickRange(startTick - 300, endTick - 300)">@MarkupStrings.NavPrevDouble</button>
	</div>
	<div class="w-10 h-10 mx-1">
		<button disabled="@f" class="@(f ? disabledStyle : enabledStyle) btn" @onclick="() => StateFacade.SelectTickRange(startTick - 60, endTick - 60)">@MarkupStrings.NavPrev</button>
	</div>
	<div class="w-10 h-10 mx-1">
		<button disabled="@l" class="@(l ? disabledStyle : enabledStyle) btn" @onclick="() => StateFacade.SelectTickRange(startTick + 60, endTick + 60)">@MarkupStrings.NavNext</button>
	</div>
	<div class="w-10 h-10 mx-1">
		<button disabled="@l" class="@(l ? disabledStyle : enabledStyle) btn" @onclick="() => StateFacade.SelectTickRange(startTick + 300, endTick + 300)">@MarkupStrings.NavNextDouble</button>
	</div>
	<div class="w-10 h-10 mx-1">
		<button disabled="@l" class="@(l ? disabledStyle : enabledStyle) btn" @onclick="() => StateFacade.SelectTickRange(replayBinary.EventsPerTick.Count - 60, replayBinary.EventsPerTick.Count)">@MarkupStrings.NavEnd</button>
	</div>
</div>

<div>
	@if (ReplayEditorState.Value.ShowTicksWithoutEvents)
	{
		<input type="checkbox" @onchange="StateFacade.ToggleShowTicksWithoutEvents" checked />
	}
	else
	{
		<input type="checkbox" @onchange="StateFacade.ToggleShowTicksWithoutEvents" />
	}

	<span>Show ticks without events</span>
</div>

<div class="grid grid-cols-4 max-w-[1024px]">
	@foreach (SwitchableEventType switchableEventType in Enum.GetValues<SwitchableEventType>())
	{
		@if (!ReplayEditorState.Value.ShownEventTypes.ContainsKey(switchableEventType))
		{
			<span class="text-red">ERROR: Invalid state; ShownEventTypes does not contain @switchableEventType.</span>
			continue;
		}

		<div>
			@if (ReplayEditorState.Value.ShownEventTypes[switchableEventType])
			{
				<input type="checkbox" @onchange="() => StateFacade.ToggleShowEventTypes(switchableEventType)" checked />
			}
			else
			{
				<input type="checkbox" @onchange="() => StateFacade.ToggleShowEventTypes(switchableEventType)" />
			}

			<span>Show @switchableEventType</span>
		</div>
	}
</div>

<button class="btn btn-gray" @onclick="StateFacade.ShowAllEvents">Show all events</button>
<button class="btn btn-gray" @onclick="StateFacade.HideAllEvents">Hide all events</button>

<div class="grid gap-4 grid-cols-8 max-w-xl">
	<span class="font-bold text-right">Tick</span>
	<span class="font-bold text-right">Time</span>
	<span class="font-bold col-span-4">Inputs</span>
	<span class="font-bold col-span-2">Events</span>
</div>

@{
	bool separator = false;
	@for (int i = startTick; i < Math.Min(replayBinary.EventsPerTick.Count, endTick); i++)
	{
		IEnumerable<IEvent> events = replayBinary.EventsPerTick[i];

		foreach (KeyValuePair<SwitchableEventType, bool> kvp in ReplayEditorState.Value.ShownEventTypes)
		{
			if (kvp.Value)
				continue;

			events = kvp.Key switch
			{
				SwitchableEventType.BoidSpawnEvent => events.Where(e => e is not BoidSpawnEvent),
				SwitchableEventType.DaggerSpawnEvent => events.Where(e => e is not DaggerSpawnEvent),
				SwitchableEventType.EntityOrientationEvent => events.Where(e => e is not EntityOrientationEvent),
				SwitchableEventType.EntityPositionEvent => events.Where(e => e is not EntityPositionEvent),
				SwitchableEventType.EntityTargetEvent => events.Where(e => e is not EntityTargetEvent),
				SwitchableEventType.GemEvent => events.Where(e => e is not GemEvent),
				SwitchableEventType.HitEvent => events.Where(e => e is not HitEvent),
				SwitchableEventType.LeviathanSpawnEvent => events.Where(e => e is not LeviathanSpawnEvent),
				SwitchableEventType.PedeSpawnEvent => events.Where(e => e is not PedeSpawnEvent),
				SwitchableEventType.SpiderEggSpawnEvent => events.Where(e => e is not SpiderEggSpawnEvent),
				SwitchableEventType.SpiderSpawnEvent => events.Where(e => e is not SpiderSpawnEvent),
				SwitchableEventType.SquidSpawnEvent => events.Where(e => e is not SquidSpawnEvent),
				SwitchableEventType.ThornSpawnEvent => events.Where(e => e is not ThornSpawnEvent),
				SwitchableEventType.TransmuteEvent => events.Where(e => e is not TransmuteEvent),
				_ => events,
			};
		}

		if (!(!ReplayEditorState.Value.ShowTicksWithoutEvents && !events.Any(e => e is not IInputsEvent)))
		{
			separator = false;
			<ReplayTick TickIndex="i" Events="events.ToList()" />
		}
		else if (!separator)
		{
			separator = true;
			<span class="text-center text-sm text-gray">[Hidden ticks]</span>
		}
	}
}
