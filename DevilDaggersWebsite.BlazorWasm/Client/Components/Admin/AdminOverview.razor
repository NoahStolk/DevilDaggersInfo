@typeparam TGetDto
@inject HttpClient Http
@inject NavigationManager NavigationManager
@using Microsoft.AspNetCore.Components.WebAssembly.Authentication
@using System.Reflection

<h1>@Title</h1>

@if (results == null)
{
	<p><em>@_uninitializedState</em></p>
}
else
{
	<table class="table">
		<thead>
			<tr>
				@foreach (PropertyInfo pi in _properties)
				{
					<th>@pi.Name</th>
				}
				<th></th>
				<th></th>
			</tr>
		</thead>
		<tbody>
			@foreach (TGetDto result in results)
			{
				<tr>
					@foreach (PropertyInfo pi in _properties)
					{
						<td>@ReflectionUtils.GetDtoPropertyDisplayValue(pi, result)</td>
					}
					<td><a href="@($"{NavigationManager.Uri}/edit/{_idProperty.GetValue(result)}")">Edit</a></td>
					<td>Delete</td>
				</tr>
			}
		</tbody>
	</table>
}

@code
{
	[Parameter] public string Title { get; set; } = null!;

	[Parameter] public string ApiRoute { get; set; } = null!;

	private TGetDto[]? results;
	private string? _uninitializedState = "Loading...";
	private PropertyInfo[] _properties = Array.Empty<PropertyInfo>();
	private PropertyInfo _idProperty = null!;

	protected override async Task OnInitializedAsync()
	{
		_properties = ReflectionUtils.GetDtoDisplayPropertyInfos<TGetDto>();
		_idProperty = _properties.First(pi => pi.Name == "Id"); // TODO: Refactor this when Blazor component type parameters support constraining.

		try
		{
			results = await Http.GetFromJsonAsync<TGetDto[]>(ApiRoute);
		}
		catch (HttpRequestException ex)
		{
			if (ex.StatusCode.HasValue)
				_uninitializedState = $"Error {(int)ex.StatusCode}: {ex.StatusCode}";
			else
				_uninitializedState = "An error occurred while sending the request.";
		}
		catch (AccessTokenNotAvailableException exception)
		{
			exception.Redirect();
		}
	}
}
