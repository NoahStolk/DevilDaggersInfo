@page
@using DevilDaggersCore.Game
@using DevilDaggersWebsite.Razor.Utils
@{
	ViewData["Title"] = "Survival Editor Guide";
}

<header>
	<h1>@ViewData["Title"]</h1>
</header>

<main role="main">
	<p>
		This page will guide you through the creation of custom spawnsets for Devil Daggers.
	</p>

	<h2>Basic information</h2>
	<p>
		The spawnset in Devil Daggers can be modified by editing a file known as the survival file. The survival file is located at <span class="path">devildaggers\dd\survival</span> where <span class="path">devildaggers</span> is the installation folder for Devil Daggers. As of the V3.1 update (February 2021), it is recommended to place custom survival files in the "mods" folder, so the custom survival file would be located at <span class="path">devildaggers\mods\survival</span>, leaving the original file intact at all times. This means replays from the official leaderboards will not be affected by the custom spawnset.
	</p>
	<p>
		The survival file consists of the following data; a list of spawns that will appear in the game, the arena (basically a grid of 51x51 tile heights), and some miscellaneous information such as brightness and how fast the arena shrinks. As of the V3.1 update, the developer has made it possible to include the initial hand upgrade, as well as additional gems, in the survival file. This means that you can now create a spawnset where you start with @RazorUtils.GetLayout(" Level 4 ", GameVersion.V31) and 20 homing daggers.
	</p>
	<p>
		All of this data can be edited using <a asp-page="/Tools/DevilDaggersSurvivalEditor">Devil Daggers Survival Editor</a>.
	</p>

	<h2>Spawns information</h2>

	<h3>Enemy types</h3>
	<p>
		10 enemies can be spawned in the survival file:
	</p>

	<ul>
		<li>@RazorUtils.GetLayout(" Squid I ", GameVersion.V31)</li>
		<li>@RazorUtils.GetLayout(" Squid II ", GameVersion.V31)</li>
		<li>@RazorUtils.GetLayout(" Centipede ", GameVersion.V31)</li>
		<li>@RazorUtils.GetLayout(" Spider I ", GameVersion.V31)</li>
		<li>@RazorUtils.GetLayout(" Leviathan ", GameVersion.V31)</li>
		<li>@RazorUtils.GetLayout(" Gigapede ", GameVersion.V31)</li>
		<li>@RazorUtils.GetLayout(" Squid III ", GameVersion.V31)</li>
		<li>@RazorUtils.GetLayout(" Thorn ", GameVersion.V31)</li>
		<li>@RazorUtils.GetLayout(" Spider II ", GameVersion.V31)</li>
		<li>@RazorUtils.GetLayout(" Ghostpede ", GameVersion.V31)</li>
		<li>EMPTY</li>
	</ul>

	<p>
		Every enemy type has a fixed amount of gems that it drops, this is why the application keeps track of gems so you can have a rough idea of when you will get upgrades (unless farming is done). It is recommended that you understand how <a asp-page="/Wiki/Upgrades">Upgrades</a> work.
	</p>

	<h3>The end loop</h3>
	<p>
		The end loop is the same set of spawns over and over again, faster every time. This appears at the end of the spawnset.
	</p>
	<p>
		You might have noticed how there is an EMPTY enemy type. This enemy type does not spawn an enemy, and its only purpose is to mark the beginning of the end loop. The last EMPTY spawn will always mark the beginning of the end loop. Having an end loop is optional, so if you don't want to include an end loop, simply make sure to put an EMPTY spawn at the end of the spawnset to mark the end of the spawnset (or literally; mark the start of an empty end loop).
	</p>
	<p>
		How the end loop speeds up appears to be hardcoded in the game. After every wave, each enemy spawns an added 12.5% faster. Also note that in @RazorUtils.GetLayout("every third wave of the end loop, all Gigapedes are changed into Ghostpedes.", GameVersion.V31) This also seems to be hardcoded in the game.
	</p>

	<h3>Spawns</h3>
	<p>
		We now know how enemy types work in Devil Daggers. A spawn in the survival file is defined by an enemy type and a delay value. The delay value represents the amount of seconds between the current spawn and the previous spawn. @RazorUtils.GetLayout("So, if you want to spawn a Squid I at 4 seconds, followed by a Squid II at 7 seconds, you would get the following spawns:", GameVersion.V31)
	</p>
	<ul>
		<li>Enemy type: @RazorUtils.GetLayout(" Squid I ", GameVersion.V31) - Delay: 4</li>
		<li>Enemy type: @RazorUtils.GetLayout(" Squid II ", GameVersion.V31) - Delay: 3</li>
	</ul>
	<p>
		The delay value supports decimal values, even though the original spawnset in the game doesn't use this. This means you can spawn an enemy, for example at 4.5 seconds.
	</p>

	<h2>Arena information</h2>
	<p>Note that you don't necessarily need to understand how the arena works, as the default arena works fine.</p>
	<ul>
		<li>The maximum arena size is 51 by 51.</li>
		<li>The player always spawns at coordinate {25, 25}.</li>
		<li>You can only have 1 tile per coordinate.</li>
		<li>The default arena size is 23 by 23 tiles at the start. This is equivalent to shrink radius 50 (technically the arena would be 25 by 25 but, because of shrinking controls, the outer tiles are already shrunk at the very beginning).</li>
		<li>The arena shrinks in size as time goes on. The default shrink start radius is 50 and the default shrink end radius is 20. The default shrink rate is 0.025. This means the default arena reaches the end radius at 1200 seconds, since (50-20)/0.025 = 1200. (Although not exactly because the shrinking radius will not hit the next tiles exactly at 1200, I haven't bothered with the math behind this, but the last tiles shrink around 1187 seconds. The shrinking technically continues for about 13 seconds but no tiles are affected by it.)</li>
		<li>The original spawnset doesn't use different tile heights, all the tiles are around height 0. (Though there are some tiny differences that are barely noticable, but for convenience we could say that all the tiles are at height 0 and that 0 is the default height.)</li>
		<li>The player can stand on tiles with height -1, but anything lower than that will result in the tile falling down immediately. All tiles below -1 are essentially the same for this reason, so the application considers any tile with a height below -1 to be "void".</li>
		<li>The tile at coordinate {1, 0} is always invisible for some reason, but you can still walk on it.</li>
		<li>The player can be spawned on different tile heights.</li>
		<li>@RazorUtils.GetLayout("Enemies and gems do not react to different tile heights, only the player, the daggers, and some effects do (like Thorn spawn smokes, meat chunks, etc).", GameVersion.V31)</li>
		<li>The maximum tile height within the application is set to 54, because anything higher than that seems unnecessary and the main light in the game doesn't reach that far so everything is completely black.</li>
		<li>There is one particular tile which causes Devil Daggers to glitch (audio glitches, hand disappearing, crashes) whenever its height is put to a value greater than 0.4973333. This tile is always at coordinate {25, 27} (just below the player spawn).</li>
		<li>The game crashes when you get too near the edge of a full arena (outside of the regular 51 by 51 range, and I think at or around coordinate {0, 0} but I am not sure).</li>
		<li>The tiles have infinitely long hitboxes, but the texture only covers the top of it.</li>
		<li>1 tile height is equivalent to 1/4 of a tile, assuming it is a cube. So if you could stack tiles on top of each other, the first tile would be at tile height 0, the second at tile height 4, the third at tile height 8, and so on.</li>
		<li>The player's jump height is equivalent to 1 tile height (1/4 of a tile).</li>
		<li>The player's maximum single dagger jump height is around 5.2 tile heights.</li>
		<li>The player's maximum double dagger jump height is around 8.4 tile heights.</li>
	</ul>
	@*
		<h3>End loop timing calculation (C# sample)</h3>
		<pre>
		using System;

		namespace DevilDaggersEndLoop
		{
			public static class Program
			{
				public static void Main()
				{
					const float physicsTick = 1 / 60f;

					int[] loopSeconds = new int[] { 5, 8, 11, 16, 21, 22, 23, 33, 34, 35, 40, 41, 46, 51, 56 }; // Hardcoded end-loop timing offsets from the original spawnset

					double waveModifier = 0.0;
					double seconds = 451.0; // Loop start

					for (int i = 0; i < 20; i++) // Wave index
					{
						double enemyTimer = 0.0;
						for (int j = 0; j < loopSeconds.Length; j++)
						{
							while (enemyTimer < loopSeconds[j])
							{
								seconds += physicsTick;
								enemyTimer += physicsTick + waveModifier;
							}
							Console.WriteLine((Math.Floor(seconds * 60) / 60).ToString(FormatUtils.SpawnTimeFormat));
						}
						waveModifier += physicsTick / 8.0; // After every end wave, each enemy spawns an added 12.5% (100% / 8) faster.
					}
				}
			}
		}</pre>*@
</main>
